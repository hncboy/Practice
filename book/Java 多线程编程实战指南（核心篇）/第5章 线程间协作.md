面向对象的世界中类不是孤立的，一个类往往需要借助其他类才能完成一个计算。同样。多线程世界中的线程并不是孤立的，一个线程往往需要其他线程的写作才能够完成其待执行的任务。

# 一、等待与通知：wait/notify

一个线程因其执行目标动作所需的保护条件未满足而被暂停的过程就被称为**等待（Wait**）。一个线程更新了系统的状态，使得其他线程所需的保护条件得以满足的时候唤醒那些被暂停的线程的过程就被称为**通知（Notify）**。

## 1.wait/notify 的作用与用法

Object.wait()/Object.wait(long)、Object.notify()/Object.notifyAll() 都可以实现等待和通知。

Object.wait() 的作用是使其执行线程被暂停（线程状态变为 WWAITING），该方法用来实现等待。Object.notify() 的作用使唤醒一个被暂停的线程，调用该方法可实现通知。Object.wait() 的执行线程被称为**等待线程**，Object.notify() 的执行线程被称为**通知线程**。因为 Object 类是 Java 中任何对象的父类，所以使用 Java 中的任何对象都可以实现等待和通知。

### 1.1 wait 方法

Object.wait() 实现等待的伪代码如下，包含该述模板代码的方法称为**受保护方法**。受保护方法包含三个要素：保护条件、暂停当前线程、执行目标动作。

```java
// 调用 wait() 方法之前需要获得相应对象的内部锁
synchronized(someObject) {
    while (保护条件不成立) {
        // 调用 Object.wait() 方法暂停当前线程
        someObject.wait();
    }
    // 保护条件满足，执行目标动作
    doAction();
}
```

保护条件是一个包含**共享变量**的布尔表达式，当共享变量被其他线程（通知线程）更新后会使得相应的保护条件得以成立，这些线程会通知等待线程。一个线程只有在持有一个对象内部锁的情况下才能调用该对象的 wait() 方法，所以 wait() 方法的使用只能放在相应对象所引导的临界区（该对象的锁）中。

假设 someObject 为 Java 任意类的实例，因执行 someObject.wait() 而被暂停的线程就称为对象 someObject 上的等待线程。由于 someObject.wait() 可以被多个线程执行，因此一个对象可能会存在多个等待线程。someObject 对象上的等待线程可以通过其他线程执行 someObject.notify() 来唤醒。someObject.wait() 会以原子操作的方式使其执行线程（当前线程）暂停并使该线程释放其持有的 someObject 对应的内部锁（wait 方法会释放锁）。当前线程虽然被暂停，但是对 someObject.wait() 的调用并没有返回，其他线程在该线程所需的保护条件成立的时候执行 someObject.notify() 唤醒 someObject 上的任意一个等待线程。等待线程被唤醒后，在其占用处理器资源继续运行的时候，需要重新申请 someObject 对应的内部锁。，此时被唤醒的线程会在其再次持有 someObjct 对应内部锁的情况下继续执行 someObject.wait() 中剩余的指令，直到 wait 方法返回。

等待线程只有在保护条件不成立的情况下才会执行  Object.wait() 进行等待。但是在等待线程被唤醒、继续运行到其再次持有锁的过程中，可能会由于其他线程抢先获得相应的内部锁并更新相关共享变量导致保护条件不成立。所以，对保护条件的判断以及 Object.wait() 的调用应该放在循环中，确保在保护条件成立的情况下才执行目标动作。

- 等待线程对保护条件的判断、Object.wait() 的调用总是应该放在相应对象所引导的临界区中的一个循环语句中。
- 等待线程对保护条件的判断、Object.wait() 的执行以及目标动作的执行必须放在同一个对象（内部锁）所引导的临界区中。
- Object.wait() 暂停当前线程时释放的锁只是与该 wait() 方法所属对象的内部锁。当前线程所持有的其他内部锁、显示锁并不会因此释放。

### 1.2 notify 方法

Object.notify() 实现通知的伪代码如下，包含该模板代码的方法被称为**通知方法**。包含更新共享变量和唤醒等待线程这两个要素。

```java
synchronized(someObject) {
    // 更新等待线程中保护条件涉及的共享资源
    updateSharedstate();
    // 随机唤醒一个等待线程
    someObject.notify();
}
```

一个线程只有在持有一个对象内部锁的情况下才能执行该对象的 notify 方法，因此 Object.notify() 的调用总是放在相应对象内部锁所引导的临界区中。因为 Object.notify() 方法的执行必须持有该方法所属的内部锁，所以 Object.wait() 在暂停其执行线程的同时必须释放相应的内部锁。不然的话，通知线程无法获得相应的内部锁，就无法调用 Object.notify() 方法了。不过 Object.notify() 的执行并不会释放内部锁，需要将该对象持有内部锁的临界区代码全部执行完才会释放。因此，为了使等待线程在其被唤醒后能尽快的获取相应的内部锁，所以要尽量将 Object.notify() 方法放在靠近临界区结束的地方。等待线程在被唤醒后会占用处理器继续运行，如果此时有其他线程获得了相应的内部锁，那么等待线程会被阻塞，这会导致上下文切换。

Object.notify() 只会唤醒相应对象上的任意一个等待线程，可能那个被唤醒的线程不是我们想要的。因此，有时候可以通过 Object.notifyAll() 唤醒该对象上的所有等待线程。

因为等待线程和通知线程在其实现等待和通知的时候必须是调用同一个对象的 wait() 方法和 notify() 方法，而这两个方法都要求其执行线程必须持有该方法所属对象的内部锁，因此等待线程和通知线程是同步在同一对象上的两种线程。

### 1.3 内部实现

Java 虚拟机会为每个对象维护一个入口集（Entry Set）用于存储申请该对象内部锁的线程。此外，Java 虚拟机还会为每个对象维护一个被称为等待集（Wait Set）的队列，该队列用于存储该对象上的等待线程。Object.wait() 将当前线程暂停并释放相应内部锁的同时会将当前线程对象存入该方法所属对象的等待集中。

执行一个对象的 notify 方法会使该对象等待集中的一个任意线程唤醒。被唤醒的线程仍然会停留在相应对象的等待集中，直到该线程再次持有相应对象内部锁的时候才会使当前线程从其所在的等待集中移除，然后 Object.wait() 就返回了。

Object.wait()/notify() 实现的等待/通知的几个关键动作，包括将当前线程加入等待集、暂停当前线程、释放锁以及将唤醒后的等待线程从等待集中移除等，都是在 Object.wait() 中实现的。Object.wait() 的部分内部实现伪代码如下。

```java
public final void wait() {
	// 线程必须持有当前对象对应的内部锁
    if (!Thread.holdsLock(this)) {
     	throw new IllegalMonitorStateException();   
    }
    
    if (当前对象不在等待集中) {
        // 将当前线程加入当前对象的等待集中
        addToWaitSet(Thread.currentThread());
    }
    
    // 原子操作
    atomic {
        // 释放当前对象的内部锁
        releaseLock(this);
        // 暂停当前线程
        block(Thread.currentThread); // 语句1
    }
    
    // 再次申请当前对象的内部锁
    acquireLock(this); // 语句2
    // 将当前线程从当前对象的等待集中移除
    removeFromWaitSet(Thread.currentThread);
    // 返回
    return;
}
```



等待线程在执行语句1的时候被暂停了。被唤醒的线程在其占用处理器继续运行的时候会继续执行其暂停前调用的 Object.wait() 中的其他指令，即从语句2开始执行：先再次申请 Object.wait() 所属对象的内部锁（没申请到就阻塞），接着将当前线程从当前对象的等待集中移除，然后 Object.wait() 调用才返回。

## 2.wait/notify 的开销及问题

## 3.Object.notify()/notifyAll() 的选用

## 4.wait/notify 与 Thread.join()

