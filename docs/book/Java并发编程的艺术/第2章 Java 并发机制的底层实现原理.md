# 一、volatile 的应用
## 1.volatile 的定义
volatile 是轻量级的 synchronized，它在多处理器开发中保证了共享变量的“可见性”。可见性指的是当一个线程修改一个共享变量时，另外一个线程能读取到这个修改的值。如果 volatile 变量修饰符使用恰当的话，它比 synchronized 的使用和执行成本更低，因为它不会引起线程上下文的切换和调度。

Java 语言规范第 3 版中的定义：Java 编程语言允许线程访问共享变量，为了确保共享变量能被准确和一致地更新，线程应该确保通过排他锁单独获得这个变量。

如果一个字段被声明成 volatile，Java 线程内存模型确保所有线程看到这个变量的值是一致的。

## 2.volatile 的实现原理
CPU 的术语定义

| 术语       | 英文单词               | 术语描述                                                     |
| ---------- | ---------------------- | ------------------------------------------------------------ |
| 内存屏障   | memory barriers        | 是一组处理器指令，用于实现对内存操作的顺序限制               |
| 缓冲行     | cache line             | CPU 高速缓存中可以分配的最小存储单位。处理器填写缓存行时会加载整个缓存行，现代 CPU 需要执行几百次 CPU 指令 |
| 原子操作   | atomic operations      | 不可中断的一个或一系列操作                                   |
| 缓存行填充 | cache line fill        | 当处理器识别到从内存中读取操作是可缓存的，处理器读取整个高速缓存行到适合的缓存（L1，L2，L3 的或所有） |
| 缓存命中   | cache hit              | 如果进行高速缓存行填充操作的内存位置仍然是下次处理器访问的地址时，处理器从缓存中读取操作数，而不是从内存中读取 |
| 写命中     | write hit              | 当处理器将操作数写回到一个内存缓存的区域时，它首先会检查这个缓存的内存地址是否在缓存行中，如果存在一个有效的缓存行，则处理器将这个操作数写回到缓存，而不是写回到内存，这个操作被称为写命中 |
| 写缺失     | write misses the cache | 一个有效的缓存行被写入到不存在的内存区域                     |

在 X86 处理器下通过打印汇编指令，发现加了 volatile 关键字后，汇编代码中多出 lock 指令，不加则没有。通过查阅 IA-32 架构软件开发手册第三册的多处理器管理章节可知，Lock 前缀的指令在多核处理器下会引发两件事情：

- 将当前处理器缓存行写回到系统内存。
- 这个写回内存的操作会使在其他 CPU 里缓存了该内存地址的数据无效。

为了提高处理速度，处理器不直接和内存进行通信，而是先将系统内存的数据读到内部缓存（L1，L2 或其他）后再进行操作，但是操作系统也不知道何时会写到内存。在声明变量前加了 volatile 关键词后，JVM 会像处理器发送一条加了 Lock 前缀的指令，将该变量所在的缓存行数据写回到系统内存。但是其他的处理器的缓存还是旧值，因此，在多处理器下，为了保证各个处理器的缓存是一致的，就要实现**缓存一致性协议**，每个处理器通过嗅探在总线上传播的数据来检查自己的缓存是否需要更新，当处理器发现自己缓存对应的内存地址被修改后，就会将当前处理器的缓存行设置成无效状态，当处理器对这个数据进行操作时，会重新从系统内存中读取数到处理器缓存中。

volatile 具体的两条实现原则

1. Lock 前缀指令会引起处理器缓存写回到内存。



2. 一个处理器的缓存写回到内存会导致其他处理器的缓存无效。



## 3.volatile 的使用优化

todo

# 二、synchronized 的实现原理与应用

Java 中的每一个对象都可以作为锁，3 种表现形式如下：
- 对于普通同步方法，锁是当前实例对象。
- 对于静态同步方法，锁是当前类的 Class 对象。
- 对于同步方法块，锁是 Synchronized 括号里配置的对象。

当一个线程试图访问同步代码块时，它首先必须得到锁，退出或抛出异常时必须释放锁。JVM 基于进入和退出 Monitor 对象来实现方法同步和代码块同步，但两者的实现细节不一样。代码块同步是使用 monitorenter 和 monitorexit 指令实现的，而方法同步是使用另外一种方式实现的，细节在 JVM 规范里并没有详细说明。同步代码块方法的字节码文件中包含了方法开始的 monitorenter 指令和正常结束以及异常结束的 monitorexit 指令，而同步方法中的字节码文件则没有这两个指令。

demo1 和 demo2 方法中的字节码文件无 monitorenter  和 monitorexit 指令，而 demo3 和 demo4 方法则有。

```java
public synchronized void demo1() {}
public synchronized static void demo2() {}
public void demo3() {
    synchronized (this) {}
}
public void demo4() {
    synchronized (SynchronizedDemo.class) {}
}
```

monitorenter 指令是在编译后插入到同步代码块的开始位置，monitorexit 指令会插入到方法的结束处和异常处。JVM 保证每个 monitorenter 都必须有对应的 monitorexit。每个对象都有一个 monitor 关联，当且一个 monitor 被持有后，它将处于锁定状态。线程执行到 monitorenter 指令时，会尝试获取对象对应的 monitor，即尝试获得对象的锁，如果没有获得，该线程会加入同步队列，直到获得 monitor 的线程调用 monitorexit 指令释放对象后，处于同步队列的线程会被唤醒，再次去争抢 monitor。

## 1.Java 对象头

synchronized 用的锁是存在 Java 对象头里的。如果对象是数组类型，则虚拟机用 3 个字宽存储对象头，如果对象是非数组类型，则用 2 字宽存储对象头。在 32 位虚拟机中，1 字(word) = 4 字节(byte) = 32 位(bit)。在 64 位虚拟机中， 1 字(word) = 8 字节(byte) = 64 位(bit)。

Java 对象头的长度如下表所示，Mark Word 和 Class Metadata Address 是每个对象都有的，数组类型对象相比其多出一个 Array Length。

| 长度      | 内容                   | 说明                             |
| --------- | ---------------------- | -------------------------------- |
| 32/64 bit | Mark Word              | 存储对象的 hashCode 或锁信息     |
| 32/64 bit | Class Metadata Address | 存储到对象类型数据的指针         |
| 32/64 bit | Array Lengh            | 数组的长度（如果当前对象是数组） |

Java 对象头里的 Mark Word 里默认存储对象的 HashCode、分代年龄和锁标记位。



## 2.锁的升级和对比
Java SE 1.6 为了减少获得锁和释放锁带来的性能消耗，引入了“偏向锁”和“轻量级锁”。在 Java SE 1.6 中，锁有 4 种状态，级别从低到高依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态。🔒可以升级但不能下降，这种策略目的是为了提高获得锁和释放锁的效率。

### 2.1 偏向锁

大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低引入了偏向锁。当一个线程访问同步块并获取锁时，会在**对象头和栈帧**中的**锁记录**里存储锁偏向的**线程 ID**，以后该线程在进入和退出同步块时不需要进行 CAS 操作来加锁和解锁，只需要测试下对象头的 Mark Word 里是否存储着指向当前线程的偏向锁。

如果测试成功，表示当前线程已经获得了该偏向锁。如果测试失败，则需要再测试下 Mark Word 中偏向锁的标识是否设置成 1（表示当前是偏向锁的标志，即判断是否存在偏向锁）：如果没有设置，则使用 CAS 竞争锁（设置偏向锁，并将对象头的 Mark Word 中的线程 ID 指向当前线程）；如果设置了，则尝试使用 CAS 将对象头的偏向锁指向当前线程。

#### 撤销偏向锁

偏向锁使用了一种等到竞争出现才释放锁的机制，所以当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁。偏向锁的撤销，需要等待全局安全点（Safe Point 在这个时间点上没有正在执行的字节码）。它会首先暂停拥有偏向锁的线程，然后检查持有偏向锁的线程是否存活，如果线程不处于活动状态，则将对象头设置成无锁状态。如果线程仍然存活，拥有偏向锁的**栈**会被执行，遍历偏向锁的锁记录，栈中的锁记录和对象头的 Mark Word 要么重新偏向于其他线程，要么恢复到无锁或者标记对象不适合作为偏向锁，最后唤醒暂停的线程。

偏向锁撤销后，可能处于两种状态

- 不可偏向的无锁状态：原来已经获取了偏向锁的线程可能已经执行完了同步代码块，使得对象处于“闲置状态”，相当于之前的偏向锁过期了，此时对象处于不可偏向的无锁状态。
- 不可偏向的已锁（轻量级锁）状态：原来已经获得了偏向锁的线程也可能尚未执行完同步代码块，偏向锁依然有效，此时对象被转化为被轻量级锁加锁的状态。

#### 关闭偏向锁

通过设置 JVM 参数 -XX:BiasedLockingStartupDelay=0 可关闭延迟，设置 ：-XX:-
UseBiasedLocking=false 可关闭偏向锁。

### 2.2 轻量级锁

#### 轻量级锁加锁

线程在执行同步块之前，JVM 会先在**当前线程的栈帧**中创建用于存储锁记录的空间，并将对象头中的 Mark Word 复制到锁记录中，官方称为 Displaced Mark Word。然后线程尝试使用 CAS 将对象头中的 Mark Word 替换为指向锁记录的指针。如果成功，当前线程获得锁，如果失败，表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁。

#### 轻量级锁解锁

轻量级锁解锁时，会使用原子的 CAS 操作将 Displaced Mark Word 替换回到对象头，如果成功，则表示没有竞争发生。如果失败，表示当前锁存在竞争，锁就会膨胀成重量级锁。

轻量级锁发生线程竞争时会自旋，如果持有锁的线程能在很短时间内释放资源，那么那些等待竞争锁的线程就不需要做内核态到用户态的转换，只需要自旋，等持有锁的线程释放锁后就可以立即获取锁，避免用户态到内核态切换的消耗。

因为自旋会消耗 CPU，为了避免无用的自旋（比如获得锁的线程被阻塞住了或锁的竞争激烈，可能会导致线程自旋的消耗大于线程阻塞挂起消耗的操作，其他需要 CPU 的线程又不能获取到 CPU，造成 CPU 的浪费），一旦升级为重量级锁后，就不会再恢复到轻量级锁状态。当锁处于这个状态下，其他线程试图获得锁时，都会被阻塞，当持有锁的线程释放锁之后会唤醒这些线程，被唤醒的线程就会进行新一轮的夺锁之争。

### 2.3锁的优缺点对比

| 锁       | 优点                                                         | 缺点                                           | 适用场景                               |
| -------- | ------------------------------------------------------------ | ---------------------------------------------- | -------------------------------------- |
| 偏向锁   | 加锁和解锁不需要额外的消耗，和执行非同步方法相比仅存在纳秒级的差距 | 如果线程间存在锁竞争，会带来额外的锁撤销的消耗 | 适用于只有一个线程访问同步块的场景     |
| 轻量级锁 | 竞争的线程不会阻塞，提高了程序的响应速度                     | 如果始终得不到锁竞争的线程，使用自旋会消耗 CPU | 追求响应时间<br />同步块执行速度非常快 |
| 重量级锁 | 线程竞争不使用自旋，不会消耗 CPU                             | 线程阻塞，响应时间缓慢                         | 追求吞吐量<br />同步块执行速度较长     |

# 三、原子操作的实现原理

原子（atomic）本意是“不能被进一步分割的最小粒子”，而原子操作（atomic operation）意为“不可被中断的一个或一系列操作”。

## 1.术语定义

| 术语名称     | 英文                   | 解释                                                         |
| ------------ | ---------------------- | ------------------------------------------------------------ |
| 缓存行       | Cache line             | 缓存的最小操作单位                                           |
| 比较并交换   | Compare and Swap       | CAS 操作需要输入两个数值，一个旧值（期望操作前的值）和一个新值，在操作期间先比较旧值有没有发生变化，如果没有发生变化，才交换成新值，发生了变化则不交换。 |
| CPU 流水线   | CPU pipeline           |                                                              |
| 内存顺序冲突 | Memory order violation | 内存顺序冲突一般是由假共享引起的，假共享是指多个 CPU 同时修改同一个缓存行的不同部分而引起其中一个 CPU 的操作无效，当出现这个内存顺序冲突时，CPU 必须清空流水线。 |

## 2.处理器如何实现原子操作

### 2.1 使用总线保证原子性

**第一个机制是通过总线锁保证原子性**。如果多个处理器同时对共享变量进行读改写操作（如i++），那么共享变量就会被多个处理器同时操作，这样读改写操作就不是原子性的，操作完之后共享变量的值可能会和期望不一致。

举个例子，i=1，执行两次 i++ 操作，期望结果是 3，但有可能是 2，如图所示。

<div align = "center"><img src="pics/ab7061c8-956d-47fe-a274-c4db3e70257e.png" /> </div>

原因可能是多个处理器同时从各自的缓存中读取变量 i，分别进行加 1 操作，然后分别写入到系统中。要保证读改写共享变量操作是原子性的，必须保证 CPU1 读改写共享变量的时候，CPU2 不能操作缓存了该共享变量内存地址的缓存。

处理器使用总线锁解决该问题，所谓总线锁就是使用处理器提供的一个 LOCK# 信号，当一个处理器在总线上输出此信号时，其他处理器的请求将被阻塞住，那么该处理器可以独占共享内存。

### 2.2 使用缓存锁保证原子性

**第二个机制时通过缓存锁定来保证原子性**。

### 2.3 使用锁机制实现原子操作

锁机制保证了只有获得锁的线程才能操作锁定的内存区域。