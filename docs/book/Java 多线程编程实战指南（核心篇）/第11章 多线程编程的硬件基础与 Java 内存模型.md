# 一、填补处理器与内存之间的鸿沟：高速缓存

主内存执行一次内存读/写操作的时间远远慢于处理器执行指令的时间，为了弥补处理器和主内存之间的处理器能力，硬件设计者在主内存和处理器之间引入了高速缓存（Cache）。

**高速缓存**是一种存储速率远比主存大而容量远比主存小的存储部件，每个处理器都有其高速缓存。

# 二、数据世界的交通规则：缓存一致性协议

多个线程并发访问同一个共享变量的时候，这些线程的执行处理器上的高速缓存各自都会保留一份该共享变量的副本，这就会带来一个问题：一个处理器对其副本数据更新后，其他处理器如何察觉到该更新并作出反应，以确保这些处理器后续读取该共享变量时能够读取到这个更新。这就是**缓存一致性问题**，实质就是如何防止脏数据和丢失更新问题。为了解决该问题，处理器之间需要一种通信机制——**缓存一致性协议（Cache Coherence Protocol）**。

**MESI（Modified-Exclusive-Shared-Invalid）协议**是一种广为使用的缓存一致性协议。

# 三、硬件缓冲区：写缓冲区与无效化队列

MESI 协议解决了缓存一致性问题，其自身也有性能弱点：处理器执行写内存操作时，必须等待其他所有处理器将其高速缓存中的相应副本数据删除并接收到这些处理器所回复的 Invalidate Acknowledge/Read Response 消息后才能将数据写入高速缓存。为了规避和减少这种等待造成的写操作的延迟，硬件设计者引入了**写缓冲区**和**无效化队列**。

## 1.存储转发

## 2.再探内存重排序

## 3.再探可见性

# 四、基本内存屏障

# 五、Java 同步机制与内存屏障

## 1.volatile 关键字的实现

## 2.synchronized 关键字的实现

## 3.Java 虚拟机对内存屏障使用的优化

## 4.final 关键字的实现

## 六、Java 内存模型

## 1.什么是 Java 内存模型

## 2.happen(s)-before 关系

## 3.再探对象的安全发布

## 4.JSR 133

早期的（JDK 5 之前）Java 内存模型存在缺陷。如一个线程线程看到一个 final 字段的默认值接着才看到该字段的初始值，这违反了 final 关键字的语义；允许 volatile 变量与普通变量的写-读操作重排序。

因此为了修复早期 Java 内存模型的缺陷，JSR-133 为 Java 语言定义了一个新的 Java 内存模型。

# 七、共享变量与性能

在多个线程共享变量的情况下，一个处理器对该变量进行更新会导致其他处理器上的高速缓冲中存储的该变量副本失效，造成这些处理器后续的写-读该变量时缓存不命中，不利于程序性能。

降低缓存未命中频率的方法：

- 多个线程之间对共享变量的访问仅仅涉及读操作而没有涉及写操作。
- 多线程之间不存在共享变量。



